# Node.js Addon
- 是一种**扩展机制**，可以调用C/C++编写原生模块
- Addon充当了Node.js和底层C/C++库之间的桥梁
- 两个api接口
    - Node-API is a C API
    - maintains a C++ wrapper module called **node-addon-api**

# 开发Node.js Addon的过程
- 编写C++模块
- 绑定到JavaScript：编写绑定代码，将C++函数和对象映射到JavaScript中，以便在Node.js环境中进行调用。
- 编译为共享库：将C++模块编译为共享库，以便在Node.js中加载和使用。
- 加载和使用Addon

# Build tools
## node-gyp
- Generate Your Projects
- GYP is a Meta-Build system: a build system that generates other build systems
- https://gyp.gsrc.io/index.md

## cmake.js
- cmake-js compile 和 cmake-js build，用于编译原生插件
- cmake-js install 则用于安装编译后的插件，很少使用

### 定义 package.json
- 可以使用 npm run 执行 package.json scripts 中的命令
- 比如：使用 npm run clean 执行，等价于 npx cmake-js clean
```
{
  "name": "build-ndk-with-cmake",
  "version": "0.0.0",
  "main": "hello.js",
  "private": true,
  "dependencies": {
    "cmake-js": "^7.3.1"
  },
  "scripts": {
    "clean": "cmake-js clean",
    "build": "cmake-js compile"
  }
}
```

### 根据 package.json 安装依赖
- `npm install`

### 定义源文件
- hello.js
- src/hello.cc
```
const addon = require('./build/Release/hello.node')
addon.helloWorld("hello", "world");
console.log("Hello World js");

#define NAPI_EXPERIMENTAL
#include <node_api.h>
#include <stdio.h>

// napi_callback_info 代表所有傳入的參數內容
napi_value hello_word (napi_env env, napi_callback_info info) {
    // 總共有兩個參數 
    size_t argc = 2;
    // 從 JavaScript 傳入的參數皆為 napi_value，所以定義一個 napi_value 的 array
    napi_value args[2];
    // 透過 N-API method 來獲得參數內容
    napi_get_cb_info(env, info, &argc, args, NULL, NULL);
    
    // 不過 napi_value 無法直接被 c/c++ code 使用，所以要再使用 N-API，來獲得實際的值
    char str1[100], str2[100];
    size_t str_size;
    napi_get_value_string_utf8(env, args[0], str1, NAPI_AUTO_LENGTH, &str_size);
    napi_get_value_string_utf8(env, args[1], str2, NAPI_AUTO_LENGTH, &str_size);
    
    printf("evan %s\n", "str1");
    printf("%s, %s \n", str1, str2); // output: Hello, world
    
    // 反之，如果想要回傳值到 JavaScript code，必須也使用 N-API 來進行轉換
    napi_value result;
    int number = 1;
    napi_create_int32(env, number, &result);
    
    return result;
  }

napi_value Init (napi_env env, napi_value exports) {
    // 將實作的 method 註冊成 property，如果沒有此定義，則無法在 JavaScript code 中使用。
    napi_property_descriptor desc = { "helloWorld", 0, hello_word, 0, 0, 0, napi_default, 0 };
    napi_status status = napi_define_properties(env, exports, 1, &desc);
    if (status != napi_ok) return NULL;
    return exports;
}
// 註冊 module
NAPI_MODULE(NODE_GYP_MODULE_NAME, Init); 
```

### 定义 CmakeLists.txt
```
cmake_minimum_required(VERSION 3.15)
project (hello)

# 包含头文件和源文件
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SOURCE_FILES "./src/*")

# 创建一个共享库（动态库）, 包含 CMake.js 提供的额外源文件
add_library(${PROJECT_NAME} SHARED ${SOURCE_FILES} ${CMAKE_JS_SRC})
# libhello 变为 hello.node
set_target_properties(${PROJECT_NAME} PROPERTIES PREFIX "" SUFFIX ".node")
# 添加 CMake.js 提供的头文件目录
target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_JS_INC})
# 链接 CMake.js 提供的库
target_link_libraries(${PROJECT_NAME} PRIVATE ${CMAKE_JS_LIB})

# Windows系统 特定配置
if(MSVC AND CMAKE_JS_NODELIB_DEF AND CMAKE_JS_NODELIB_TARGET)
  # Generate node.lib
  execute_process(COMMAND ${CMAKE_AR} /def:${CMAKE_JS_NODELIB_DEF} /out:${CMAKE_JS_NODELIB_TARGET} ${CMAKE_STATIC_LINKER_FLAGS})
endif()
```

### 编译
- npx cmake-js clean
- npx cmake-js build 或者 npm run build
- 输出 build/Release/hello.note
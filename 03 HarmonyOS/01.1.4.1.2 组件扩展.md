# 组件扩展
- @Builder装饰器和@Component装饰器的区别：
    - @Builder装饰器
        - 控件级
        - 用于封装可复用的**UI结构**
        - 该装饰器**严格禁止在其内部定义状态变量或使用生命周期函数**，必须通过参数传递的方式与调用方完成数据交互。
    - @Component装饰器
        - 页面级
        - 作为封装复杂**UI组件**的核心机制，允许开发者通过组合多个基础组件来构建可复用的复合界面。
        - 该装饰器不仅支持内部状态变量的定义，还能完整管理组件的生命周期。
- @Builder装饰器是@BuilderParam装饰器、@LocalBuilder装饰器和wrapBuilder的基石。
- @Builder装饰器
    - 可**复用的UI结构**而设计
    - 其内部**禁止定义状态变量和调用组件生命周期方法**
    - 在函数内部修改入参内容会报错
- @LocalBuilder装饰器
    - 在使用@Builder实现组件间数据传递时，开发者需注意组件层级关系  
    - 只针对 定义@LocalBuilder的组件作出改变
        - this 永远指向定义 @LocalBuilder 的组件
        - 如果在子组件中使用，状态变量永远不会在子组件中更新      
- @BuilderParam装饰器
    - 当多个场景共用同一个@Builder函数时, **类似slot占位符机制 **   
    - 专门用于接收并封装@Builder函数
    - **特别注意this指向**
    - 自定义组件内**仅有一个使用@BuilderParam装饰的属性**，可以使用 **尾随闭包**
- wrapBuilder
    - wrapBuilder返回WrappedBuilder对象，实现全局@Builder可以进行赋值和传递
    - 在同一个自定义组件内，同一个wrapBuilder只能初始化一次

# @Builder装饰器：自定义构建函数

## 装饰器使用说明
- 私有自定义构建函数
    - 在 @Component 内定义，可以定义多个
    - 该函数被认为是该组件的**私有**的成员函数
    - 可以通过this访问其他成员
- 全局自定义构建函数

## 参数传递规则
- 调用@Builder装饰的函数**默认按值传递**
- 只有当传入**一个对象字面量参数**时，才会按引用传递

# wrapBuilder：封装全局@Builder
```
class Tmp {
  paramA2: string = 'hello';
}

@Builder
function overBuilder(param: Tmp) {
  Column() {
    Text(`wrapBuildervalue:${param.paramA2}`)
  }
}

const wBuilder: WrappedBuilder<[Tmp]> = wrapBuilder(overBuilder);

@Entry
@Component
struct Parent {
  @State label: Tmp = new Tmp();

  build() {
    Column() {
      wBuilder.builder({ paramA2: this.label.paramA2 })
      Button('Click me').onClick(() => {
        this.label.paramA2 = 'ArkUI';
      })
    }
  }
}
```

# 综合例子
```
class Data {
  size: number = 1;
}

@Entry
@Component
struct Parent {
  label: string = 'parent';
  @State data: Data = new Data();

  // 作为 slot 在 Child 中使用
  // this 指向 Child 中的 label
  // $$ 指向 Parent 中的 data
  @Builder
  componentBuilder($$: Data) {
    Text(`builder + $$`)
    Text(`${'this -> ' + this.label}`)
    Text(`${'size : ' + $$.size}`)
  }

  // 作为 slot 在 Child 中使用
  // this 指向 Parent 中的 label
  // $$ 指向 Parent 中的 data, 因为 componentLocalBuilder 绑定于父组件
  // $$.size 在点击button后不更新，因为 @LocalBuilder 在子组件中使用，而 @LocalBuilder 的刷新，只会针对于父组件
  @LocalBuilder
  componentLocalBuilder($$: Data) {
    Text(`LocalBuilder + $$ data`)
    Text(`${'this -> ' + this.label}`)
    Text(`${'size : ' + $$.size}`)
  }

  @LocalBuilder
  contentLocalBuilderNoArgument() {
    Text(`LocalBuilder + local data`)
    Text(`${'this -> ' + this.label}`)
    Text(`${'size : ' + this.data.size}`)
  }

  build() {
    Column() {
      // 和 child 中的 componentLocalBuilder 比较
      this.componentLocalBuilder({size:this.data.size})
      Text("  ")
      Child({
        contentBuilder: this.componentBuilder,
        contentLocalBuilder: this.componentLocalBuilder,
        contentLocalBuilderNoArgument: this.contentLocalBuilderNoArgument,
        data: this.data
      })
    }
  }
}

@Component
struct Child {
  label: string = 'child';
  @Builder customBuilder() {};
  @BuilderParam contentBuilder: ((data: Data) => void) = this.customBuilder;
  @BuilderParam contentLocalBuilder: ((data: Data) => void) = this.customBuilder;
  @BuilderParam contentLocalBuilderNoArgument: (() => void) = this.customBuilder;
  @Link data: Data;

  build() {
    Column() {
      this.contentBuilder({ size: this.data.size })
      this.contentLocalBuilder({ size: this.data.size })
      this.contentLocalBuilderNoArgument()
      Button("add child size").onClick(() => {
        this.data.size += 1;
      })
    }
  }
}
```
- startService一般是绑定后台服务
- bindService适合通信的时候绑定

![](../../../photo/Pasted%20image%2020250311183451.png)
![](../../../photo/Pasted%20image%2020250311183712.png)

# onDestroy 的执行时机
1. **StopService() 被调用**: 当应用调用 `stopService()` 方法时，Service 将被停止，触发 `onDestroy()` 方法。
2. **调用 stopSelf()**: 如果 Service 内部完成了任务，可能会调用 `stopSelf()` 方法停止自己。
3. **系统资源紧张**: 在一些特定情况下，系统会主动停止 Service，比如设备内存不足等情况。

# Service和线程的对比
- Service更侧重于任务的组织和管理
- 线程是任务执行的实际单元
- 
- Service本身不直接占用CPU资源，它只是一个组件，需要通过线程或其他机制来执行实际的任务
- 线程会占用一定的系统资源，包括线程栈空间、线程上下文等
- 
- 适用场景
    - **Service：适用于需要在后台执行任务的场景**，例如：
        - 背景音乐播放。
        - 文件下载。
        - 定时任务（如定时同步数据）。
        - 提供跨进程服务（如Android中的AIDL）。
    - **线程： 适用于需要并发执行任务的场景**，例如：
        - 多任务处理（如多用户请求处理）。
        - 资源密集型任务（如计算密集型任务）。
        - 提高程序响应速度（如UI线程与后台线程分离）。

# Service​分类
- **前台服务**：
	- **前台服务会在通知栏显示一个通知，表明该服务正在运行。例如，音乐播放器的播放服务**，用户在使用其他应用时也能通过通知栏控制音乐播放。
	- **前台服务具有较高的优先级，不容易被系统杀死**，因为它对用户体验有直接影响。​
- **后台服务**：
	- **后台服务在后台运行，没有可见的用户界面，如数据同步服务。**
	- **它在系统资源紧张时可能会被系统杀死**。为了提高后台服务的存活几率，可以采用一些优化策略，如使用 JobScheduler 在合适的时机执行任务，减少服务的运行时间。
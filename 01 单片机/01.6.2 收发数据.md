- 注意 SBUF
	- 同地址但双缓冲
	- 当执行**发送操作**（如`MOV SBUF, A`）时，数据会写入**发送缓冲器**，触发串口发送过程。
	- 当执行**接收操作**（如`MOV A, SBUF`）时，实际读取的是**接收缓冲器**中已接收的数据。
# 发送数据
![](../photo/Pasted%20image%2020250822120234.png)
- **总结：发送数据只需要将待发送的数据写入SBUF即可**
1. 写数据。将待发送的8位数据写入**发送缓冲器（SBUF）**
2. 组装数据帧。此时 **发送控制器（Tx Control）** 就会开始工作，它会自动为数据添加起始位和结束位，从而构成一个完整的UART数据帧
3. 逐位通过TxD引脚输出出去
4. 产生中断。当完成一个数据帧的输出之后，发送控制器会将发送**中断控制位TI置1**，向CPU请求中断，CPU检测到中断请求后就执行相应的中断服务程序

# 接收数据
![](../photo/Pasted%20image%2020250822120624.png)
- **总结：接收数据需要先使能接收，也就是将REN控制位置1，然后开启串口中断，并在中断服务程序中读取SBUF。**
1. 默认情况下，串口并不会接收数据
2. 使能接收。将 **REN（Receive Enable）** 控制位置为1，REN控制位位于 **SCON** 寄存器
	![](../photo/Pasted%20image%2020250822121105.png)
3. 检测RxD引脚的起始位。**1到0跳变检测器（1-To-0 Transition Detector）** 就会开始工作，具体来讲就是不断检测RxD引脚的起始位
4. 接收数据。当检测到1到0的跳变后，就会启动**接收控制器（Rx Control）**，接收控制器会将接收到数据逐位移入到**输入移位寄存器（Input Shift REG）**，直到接收到停止位，就算完成了一帧数据的接收
5. 写入缓存区。正常情况下，接下来，**接收控制器** 会将 **输入移位寄存器（Input Shift REG）** 中的数据加载到 **读取缓冲器（SBUF）** 中，并将读取**中断控制位RI置1**，向CPU请求中断，CPU检测到中断请求后就执行相应的中断服务程序，开发者就能在中断服务程序中读取SBUF获取当前帧的数据了。
	- **结束位正常**
		- **开发者可以配置是否检测停止位的有效性（高电平有效）**
		- SM2=1时，接收控制器就会检测控制停止位，当SM2=0时，则不会检测停止位，建议将SM2设置为0
		- ![](../photo/Pasted%20image%2020250822121551.png)
	- 读取中断标志位为复位状态
		- 读取中断标志位RI必须等于0，也就说要保证上一帧数据已经被读取或处理完毕，才能处理当前帧
		- 否则丢弃数据
		- **所以中断处理程序代码一定要简单**

# 代码设计
- 发送和接收的中断是同一个，根据不同的寄存器区分
- 发送和接收的逻辑要分开
	- 他们的中断优先级是一样的
	- 写在一块，一个未执行完毕，就执行另一个，
		